//!
//! generated by flatc-zig
//! binary:     gen/home/travis/Downloads/flatbuffers/reflection/reflection.bfbs
//! schema:     /home/travis/Downloads/flatbuffers/reflection/reflection.fbs
//! file ident: //reflection.fbs
//! typename    reflection.SchemaFile
//!

const std = @import("std");
const fb = @import("flatbufferz");
const Builder = fb.Builder;

// a namespace generated by flatc-zig to match typenames produced by flatc
const reflection = struct {
    const SchemaFile = @import("SchemaFile.fb.zig").SchemaFile;
    const SchemaFileT = @import("SchemaFile.fb.zig").SchemaFileT;
};

/// File specific information.
/// Symbols declared within a file may be recovered by iterating over all
/// symbols and examining the `declaration_file` field.
pub const SchemaFile = struct {
    _tab: fb.Table,

    pub fn GetRootAs(buf: []u8, offset: u32) reflection.SchemaFile {
        const n = fb.encode.read(u32, buf[offset..]);
        return reflection.SchemaFile.init(buf, n + offset);
    }

    pub fn GetSizePrefixedRootAs(buf: []u8, offset: u32) reflection.SchemaFile {
        const n = fb.encode.read(u32, buf[offset + fb.Builder.size_u32 ..]);
        return reflection.SchemaFile.init(buf, n + offset + fb.Builder.size_u32);
    }

    pub fn init(bytes: []u8, pos: u32) SchemaFile {
        return .{ ._tab = .{ .bytes = bytes, .pos = pos } };
    }

    pub fn Table(x: SchemaFile) fb.Table {
        return x._tab;
    }

    /// Filename, relative to project root.
    pub fn Filename(rcv: SchemaFile) []const u8 {
        const o = rcv._tab.offset(4);
        if (o != 0) {
            return rcv._tab.byteVector(o + rcv._tab.pos);
        }
        return "";
    }

    pub fn KeyCompare(o1: u32, o2: u32, buf: []u8) bool {
        const obj1 = SchemaFile.init(buf, @as(u32, @intCast(buf.len)) - o1);
        const obj2 = SchemaFile.init(buf, @as(u32, @intCast(buf.len)) - o2);
        return std.mem.lessThan(u8, obj1.Filename(), obj2.Filename());
    }

    pub fn LookupByKey(rcv: *SchemaFile, key: []const u8, vector_loc: u32, buf: []u8) bool {
        var span = fb.encode.read(u32, buf[vector_loc - 4 ..][0..4]);
        var start: u32 = 0;
        while (span != 0) {
            var middle = span / 2;
            const table_off = fb.getIndirectOffset(buf, vector_loc + 4 * (start + middle));
            const obj = SchemaFile.init(buf, table_off);
            const order = std.mem.order(u8, obj.Filename(), key);
            if (order == .gt) {
                span = middle;
            } else if (order == .lt) {
                middle += 1;
                start += middle;
                span -= middle;
            } else {
                rcv.* = SchemaFile.init(buf, table_off);
                return true;
            }
        }
        return false;
    }

    /// Names of included files, relative to project root.
    pub fn IncludedFilenames(rcv: SchemaFile, j: usize) ?[]const u8 {
        const o = rcv._tab.offset(6);
        if (o != 0) {
            const a = rcv._tab.vector(o);
            return rcv._tab.byteVector(a + @as(u32, @intCast(j)) * 4);
        }
        return "";
    }

    pub fn IncludedFilenamesLen(rcv: SchemaFile) u32 {
        const o = rcv._tab.offset(6);
        if (o != 0) {
            return rcv._tab.vectorLen(o);
        }
        return 0;
    }

    pub fn Start(__builder: *Builder) !void {
        try __builder.startObject(2);
    }
    pub fn AddFilename(__builder: *Builder, filename: u32) !void {
        try __builder.prependSlotUOff(0, filename, 0);
    }

    pub fn AddIncludedFilenames(__builder: *Builder, included_filenames: u32) !void {
        try __builder.prependSlotUOff(1, included_filenames, 0);
    }

    pub fn StartIncludedFilenamesVector(__builder: *Builder, num_elems: i32) !u32 {
        return __builder.startVector(4, num_elems, 4);
    }
    pub fn End(__builder: *Builder) !u32 {
        return __builder.endObject();
    }
};
