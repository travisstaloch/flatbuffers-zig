//!
//! generated by flatc-zig
//! binary:     gen/home/travis/Downloads/flatbuffers/reflection/reflection.bfbs
//! schema:     /home/travis/Downloads/flatbuffers/reflection/reflection.fbs
//! file ident: //reflection.fbs
//! typename    reflection.Field
//!

const std = @import("std");
const fb = @import("flatbufferz");
const Builder = fb.Builder;

// a namespace generated by flatc-zig to match typenames produced by flatc
const reflection = struct {
    const Type = @import("Type.fb.zig").Type;
    const TypeT = @import("Type.fb.zig").TypeT;
    const Field = @import("Field.fb.zig").Field;
    const FieldT = @import("Field.fb.zig").FieldT;
    const KeyValue = @import("KeyValue.fb.zig").KeyValue;
    const KeyValueT = @import("KeyValue.fb.zig").KeyValueT;
};

pub const Field = struct {
    _tab: fb.Table,

    pub fn GetRootAs(buf: []u8, offset: u32) reflection.Field {
        const n = fb.encode.read(u32, buf[offset..]);
        return reflection.Field.init(buf, n + offset);
    }

    pub fn GetSizePrefixedRootAs(buf: []u8, offset: u32) reflection.Field {
        const n = fb.encode.read(u32, buf[offset + fb.Builder.size_u32 ..]);
        return reflection.Field.init(buf, n + offset + fb.Builder.size_u32);
    }

    pub fn init(bytes: []u8, pos: u32) Field {
        return .{ ._tab = .{ .bytes = bytes, .pos = pos } };
    }

    pub fn Table(x: Field) fb.Table {
        return x._tab;
    }

    pub fn Name(rcv: Field) []const u8 {
        const o = rcv._tab.offset(4);
        if (o != 0) {
            return rcv._tab.byteVector(o + rcv._tab.pos);
        }
        return "";
    }

    pub fn KeyCompare(o1: u32, o2: u32, buf: []u8) bool {
        const obj1 = Field.init(buf, @as(u32, @intCast(buf.len)) - o1);
        const obj2 = Field.init(buf, @as(u32, @intCast(buf.len)) - o2);
        return std.mem.lessThan(u8, obj1.Name(), obj2.Name());
    }

    pub fn LookupByKey(rcv: *Field, key: []const u8, vector_loc: u32, buf: []u8) bool {
        var span = fb.encode.read(u32, buf[vector_loc - 4 ..][0..4]);
        var start: u32 = 0;
        while (span != 0) {
            var middle = span / 2;
            const table_off = fb.getIndirectOffset(buf, vector_loc + 4 * (start + middle));
            const obj = Field.init(buf, table_off);
            const order = std.mem.order(u8, obj.Name(), key);
            if (order == .gt) {
                span = middle;
            } else if (order == .lt) {
                middle += 1;
                start += middle;
                span -= middle;
            } else {
                rcv.* = Field.init(buf, table_off);
                return true;
            }
        }
        return false;
    }

    pub fn Type(rcv: Field) ?reflection.Type {
        const o = rcv._tab.offset(6);
        if (o != 0) {
            const x = rcv._tab.indirect(o + rcv._tab.pos);
            return reflection.Type.init(rcv._tab.bytes, x);
        }
        return null;
    }

    pub fn Id(rcv: Field) u16 {
        const o = rcv._tab.offset(8);
        if (o != 0) {
            return rcv._tab.read(u16, o + rcv._tab.pos);
        }
        return 0;
    }

    pub fn MutateId(rcv: Field, n: u16) bool {
        return rcv._tab.mutateSlot(u16, 8, n);
    }

    pub fn Offset(rcv: Field) u16 {
        const o = rcv._tab.offset(10);
        if (o != 0) {
            return rcv._tab.read(u16, o + rcv._tab.pos);
        }
        return 0;
    }

    pub fn MutateOffset(rcv: Field, n: u16) bool {
        return rcv._tab.mutateSlot(u16, 10, n);
    }

    pub fn DefaultInteger(rcv: Field) i64 {
        const o = rcv._tab.offset(12);
        if (o != 0) {
            return rcv._tab.read(i64, o + rcv._tab.pos);
        }
        return 0;
    }

    pub fn MutateDefaultInteger(rcv: Field, n: i64) bool {
        return rcv._tab.mutateSlot(i64, 12, n);
    }

    pub fn DefaultReal(rcv: Field) f64 {
        const o = rcv._tab.offset(14);
        if (o != 0) {
            return rcv._tab.read(f64, o + rcv._tab.pos);
        }
        return 0.0e+00;
    }

    pub fn MutateDefaultReal(rcv: Field, n: f64) bool {
        return rcv._tab.mutateSlot(f64, 14, n);
    }

    pub fn Deprecated(rcv: Field) bool {
        const o = rcv._tab.offset(16);
        if (o != 0) {
            return rcv._tab.read(bool, o + rcv._tab.pos);
        }
        return false;
    }

    pub fn MutateDeprecated(rcv: Field, n: bool) bool {
        return rcv._tab.mutateSlot(bool, 16, n);
    }

    pub fn Required(rcv: Field) bool {
        const o = rcv._tab.offset(18);
        if (o != 0) {
            return rcv._tab.read(bool, o + rcv._tab.pos);
        }
        return false;
    }

    pub fn MutateRequired(rcv: Field, n: bool) bool {
        return rcv._tab.mutateSlot(bool, 18, n);
    }

    pub fn Key(rcv: Field) bool {
        const o = rcv._tab.offset(20);
        if (o != 0) {
            return rcv._tab.read(bool, o + rcv._tab.pos);
        }
        return false;
    }

    pub fn MutateKey(rcv: Field, n: bool) bool {
        return rcv._tab.mutateSlot(bool, 20, n);
    }

    pub fn Attributes(rcv: Field, j: usize) ?reflection.KeyValue {
        const o = rcv._tab.offset(22);
        if (o != 0) {
            var x = rcv._tab.vector(o);
            x += @as(u32, @intCast(j)) * 4;
            x = rcv._tab.indirect(x);
            return reflection.KeyValue.init(rcv._tab.bytes, x);
        }
        return null;
    }

    pub fn AttributesByKey(rcv: Field, obj: *reflection.KeyValue, key: []const u8) bool {
        const o = rcv._tab.offset(22);
        if (o != 0) {
            const x = rcv._tab.vector(o);
            return obj.LookupByKey(key, x, rcv._tab.bytes);
        }
        return false;
    }

    pub fn AttributesLen(rcv: Field) u32 {
        const o = rcv._tab.offset(22);
        if (o != 0) {
            return rcv._tab.vectorLen(o);
        }
        return 0;
    }

    pub fn Documentation(rcv: Field, j: usize) ?[]const u8 {
        const o = rcv._tab.offset(24);
        if (o != 0) {
            const a = rcv._tab.vector(o);
            return rcv._tab.byteVector(a + @as(u32, @intCast(j)) * 4);
        }
        return "";
    }

    pub fn DocumentationLen(rcv: Field) u32 {
        const o = rcv._tab.offset(24);
        if (o != 0) {
            return rcv._tab.vectorLen(o);
        }
        return 0;
    }

    pub fn Optional(rcv: Field) bool {
        const o = rcv._tab.offset(26);
        if (o != 0) {
            return rcv._tab.read(bool, o + rcv._tab.pos);
        }
        return false;
    }

    pub fn MutateOptional(rcv: Field, n: bool) bool {
        return rcv._tab.mutateSlot(bool, 26, n);
    }

    /// Number of padding octets to always add after this field. Structs only.
    pub fn Padding(rcv: Field) u16 {
        const o = rcv._tab.offset(28);
        if (o != 0) {
            return rcv._tab.read(u16, o + rcv._tab.pos);
        }
        return 0;
    }

    pub fn MutatePadding(rcv: Field, n: u16) bool {
        return rcv._tab.mutateSlot(u16, 28, n);
    }

    pub fn Start(__builder: *Builder) !void {
        try __builder.startObject(13);
    }
    pub fn AddName(__builder: *Builder, name: u32) !void {
        try __builder.prependSlotUOff(0, name, 0);
    }

    pub fn AddType(__builder: *Builder, @"type": u32) !void {
        try __builder.prependSlotUOff(1, @"type", 0);
    }

    pub fn AddId(__builder: *Builder, id: u16) !void {
        try __builder.prependSlot(u16, 2, id, 0);
    }

    pub fn AddOffset(__builder: *Builder, offset: u16) !void {
        try __builder.prependSlot(u16, 3, offset, 0);
    }

    pub fn AddDefaultInteger(__builder: *Builder, default_integer: i64) !void {
        try __builder.prependSlot(i64, 4, default_integer, 0);
    }

    pub fn AddDefaultReal(__builder: *Builder, default_real: f64) !void {
        try __builder.prependSlot(f64, 5, default_real, 0.0e+00);
    }

    pub fn AddDeprecated(__builder: *Builder, deprecated: bool) !void {
        try __builder.prependSlot(bool, 6, deprecated, false);
    }

    pub fn AddRequired(__builder: *Builder, required: bool) !void {
        try __builder.prependSlot(bool, 7, required, false);
    }

    pub fn AddKey(__builder: *Builder, key: bool) !void {
        try __builder.prependSlot(bool, 8, key, false);
    }

    pub fn AddAttributes(__builder: *Builder, attributes: u32) !void {
        try __builder.prependSlotUOff(9, attributes, 0);
    }

    pub fn StartAttributesVector(__builder: *Builder, num_elems: i32) !u32 {
        return __builder.startVector(4, num_elems, 1);
    }
    pub fn AddDocumentation(__builder: *Builder, documentation: u32) !void {
        try __builder.prependSlotUOff(10, documentation, 0);
    }

    pub fn StartDocumentationVector(__builder: *Builder, num_elems: i32) !u32 {
        return __builder.startVector(4, num_elems, 4);
    }
    pub fn AddOptional(__builder: *Builder, optional: bool) !void {
        try __builder.prependSlot(bool, 11, optional, false);
    }

    pub fn AddPadding(__builder: *Builder, padding: u16) !void {
        try __builder.prependSlot(u16, 12, padding, 0);
    }

    pub fn End(__builder: *Builder) !u32 {
        return __builder.endObject();
    }
};
